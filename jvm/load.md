# 类加载 #

类执行的简单过程是：java文件经过编译之后成class的jvm字节文件，执行命令 java com.Hello，调用了jvm程序，由JVM调用JAVA代码创建JVM启动器实例;由该实例负责加载创建其他类加载类；通过加载-验证-解析-初始化，然后由字节码执行引擎使用-卸载的过程

### 类加载 ###


#### 加载时机 ####
执行引擎执行字节码的过程中，遇到new,getstatic,putstatic,invokestatic指令就会执行加载。即把class文件加载到内存中。加载时机属于懒加载，只有遇到以上指令才会进行加载，B b = null不会加载；

#### 加载器的种类 ####
引导加载器(lib)->扩展类(lib/ext)->应用程序加载器(classPath)；
分别加载不同目录下的类。引导加载器是javahome的lib目录下的；扩展类加载器加载lib/ext目录，但jdk9已经废弃了ext加载器，使用平台类加载器

#### 双亲委派机制 ####
应用程序加载器加载类的时候不会自己加载，逐个向上委托，当父类加载不到的时候，自己才会加载，加载器是通过组合的方式在一起的；最终加载不到会抛出ClassNotFoundException异常；


优点：沙箱安全机制，保证核心类不被篡改；职责分明避免重复加载；不直接从上到下的原因是，代码自定义类离应用程序加载类最近，大量自定义类被加载；

缺点：父类加载器不能使用子类加载器加载的类，多版本部署需要打破双亲委派机制；


#### 如何打破双亲委派机制 ####
自定义类加载器和线程上下文加载器
打破的原因是部署应用，不同的版本号，比如tomcat；
越基础的类由高层的加载器加载，但是基础类需要调用用户代码，比如SPI（jdbc）；

> SPI是jdk内置提供的发现服务的机制，比如定义了java.sql.Driver接口，但具体实现由用户实现，所以通过SPI实现。SPI的核心思想是解耦；服务实现classpath下的META-INF/services/目录；查找服务的实现的工具类java.util.ServiceLoader；


tomcat如何打破：
各个web应用生成自己的WebAppClassLoad加载器优先加载(非基础类,java.lang.)，加载不到再交给CommonClassLoad执行双亲委派机制；
JSP类加载器(jasperLoader),每个jsp对应一个加载器,实现热加载,监听文件的变动,销毁原来的加载器,然后重新生成新的jasperLoader加载器;旧的加载器会在GC的时候回收

线程上下文加载器：
线程上下文加载器可以实现父类加载器请求子类加载器完成加载（JDBC），比如jdbc是一个标准，由启动类加载器加载。
但是具体的驱动在应用层。双亲委派，父类加载器看不到子类加载器加载的内容，所以需要线程上下文加载器。Thread.setContextClassLoader


#### 自定义类加载器并打破双亲委派 ####
继承ClassLoad类,重写findClass.思路是从磁盘读取文件,转换成字节数组byte[],然后再findClass中,调用defindClass,就会可以加载类.但是需要打破双亲委派还需要重写loadClass方法，找不到的情况下不调用父加载器的加载,而且使用自己的加载；使用的时候load =new XXXClassLoad;load.loadClass(),就能获取类Class对象；关于对象的组成，结构等知识，内存的分配在一下章介绍


以上是关于类加载的知识点，接下来需要看验证，准备，解析等操作

验证，准备，解析统称链接

### 验证 ###
主要是验证合法性，比如魔术，大小版本号，关于字节码的知识建议看下周志明的《深入理解JAVA虚拟机》字节码部分，作为知识的一个补充。

#### 准备 ####
在方法区分配内存，类静态变量初始化默认值。比如int类型的初始值0；

#### 解析 ####
class文件在编译阶段没有这一步，所以才需要解析；
将符号引用解析为直接引用。因为在准备阶段已经分配了内存，所以这步才能得以实现;解析分为静态链接,在解析阶段完成；动态链接，在运行过程中完成，比如反射调用。





