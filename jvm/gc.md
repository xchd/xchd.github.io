# GC #

#### 触发和转换 ####
新生代内存不够用的时候就会触发GC；
老年代触发GC的条件有多个：
1在minorGC之前，检测老年代剩余内存是否小于新生代
2minorGC之后，转移到老年代的空间大于老年代的剩余内存
3老年代的空间不足
4方法区空间不足

minorGC执行之前，检查老年代的剩余空间是否能装下新生代的内容，如果可以，直接执行MinorGC。minorGC之后如果survivor不够装入存活的对象，部分就会被移到老年代，年龄超过15的也转移到老年代。年龄1,2,n占用survivor的50%,那么年龄>=n的对象也移到老年代(尽量保证GC之后小于survivor的50%)，如果老年代空间不够新生代的大且老年代空间大于从新生代进入老年代的平均大小，就执行minorGC，否则就执行majorGC.如果还是存不下就OOM

#### 垃圾分析 ####
垃圾分析算法可以使用计数器和可达性算法，jvm使用可达性算法实现。从GC Roots开始收集，局部变量，静态变量，常量，native引用变量都可以作为GC roots；加速了GC Roots的枚举，使用OopMap存放着对象引用的位置；在分析的引用关系的时候，引用的类型分为强引用，软应用和弱应用，虚引用。

分析元空间的类是否有效，满足以下约束：
所有实例被回收，该类类加载器被回收，该类的Class对象没有引用；
第二点很苛刻，应为jvm提供的三个类加载器（引导，扩展，应用）是不会被回收的。回收的只能是自定义的类加载器


#### 收集算法 ####
基于分代收集理论，算法有标记复制，标记清除，标记整理


#### 三色标记算法 ####
CMS和G1在垃圾对象扫描中，判断是否是垃圾，使用三色标记算法：
三色是白，灰，黑。
白色:未被收集器访问过.默认都是白色;分析完成白色的被清除
灰:被收集器访问过,但至少存在一个对象没有被扫描,分析未完成
黑:全部成员变量对象都被收集器扫描过,且不能回收.表示分析完成

需要解决错标的问题：
在并发收集的过程中，新产生的对象直接标记黑色，这个就产生了浮动垃圾。实现(未完)

