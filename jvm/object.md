# 对象 #

#### 分配内存 ####
在类初始化加载的准备阶段分配了内存，接下来看一下创建对象的过程。如果类已经加载就不会再次加载，否则进行加载，在加载的过程分配内存的方式有两种，一种是指针碰撞，另外一种是空闲列表
指针碰撞：适用于堆内存完整的情况，已分配的内存和空闲内存分表在不同的一侧，通过一个指针指向分界点，当需要分配内存时，把指针往空闲的一端移动与对象大小相等的距离即可

空闲列表：
适用于堆内存不完整的情况，已分配的内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的内存块信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录

处理分配内存的并发问题：jvm使用cas和TLAB
TLAB：本地线程分配缓存。每个线程提前在eden区划分小一部分区域默认eden的1%，进行存放，使用参数-XX:TLABSize设置大小。如果对象过大，就使用cas分配。如果cas分配失败则重试；

#### 分配流程 ####
首先判断是否能在栈上分配，栈上分配的前提，是否开启对象逃逸分析，jdk7以后默认开启。参数是-XX:+DoEscapeAnalysis（锁消除也是在逃逸分析的基础上实现的-XX:+EliminateLocks），如果在栈上不能分配，判断是否开启标量替换，jdk7默认开启（-XX:+EliminateAllocations），因为栈空间比较小且可能有碎片，开启之后允许把对象拆散，把单个对象存入碎片中。如果不能在栈上分配就在堆中分配。在堆中分配也区分对象的大小。小对象在eden区分配，大对象存在在老年代或者是大对象区，取决于GC收集器。

#### 对象头 ####
包含markword，klass pointer，数组长度

分配内存之后就会，然后解析和初始化<clinit>，初始化之后进行对象头的设置。
对象的组成部分是对象头，实例数据，对齐填充（满足长度是8的倍数）；一个Object对象16字节
对象头包含了markword(hashcode，锁信息)，klass-point，数组长度；

markword 占用32bit(位)，的元素包含了锁状态，锁标志位，hashcode，分代年龄，是否偏向锁，以上元素是无锁的状态下。里面的元素是根据锁的状态而变化。分代年龄占用4bit，所以年龄不能大于15.如果转向偏向锁，线程ID,epoch,分代年龄.是否偏向锁,锁标志位01；如果转为轻量级锁，markword保存的是指向栈中锁记录的指针,锁标志位00；转为重量级锁指向互斥锁的指针,锁标志位10；如果是GC锁，空，锁标志位是11

klass pointer指向方法区的类信息

数组长度
4字节,有数据才存在


#### 锁升级 ####
可以关联到多线程，synchronized的知识点学习。

首先是使用的时候就会生成偏向锁，执行完同步代码块后，线程并不会主动释放偏向锁再次执行看持有锁释放自己，如果是继续执行，可重入特性；

如果其他线程尝试竞争偏向锁，就会升级到轻量级锁，一种自旋锁，等待全局安全点，升级轻量级锁。自旋锁；栈帧创建锁记录 Lock Record 的空间，markword的信息就会拷贝到栈中，通过 CAS 尝试把原对象头 Mark Word 中锁记录指针指向该锁记录

自旋超过一定次数，就会升级到重量级锁。执行 monitorenter 指令进入等待队列，就会发生阻塞，阻塞线程需要用户态到内核态的切换。Monitor是依赖于操作系统,操作系统维护这mutex的互斥量(pthread);由用户态切换成内核态,所以属于比较重的操作

#### 对象的大小 ####
new Object 16字节
byte 1字节    
short 2字节  
int  4字节
long 8字节

float   4字节
double  8字节

char 2字节
boolean 1字节


查看占用大小使用jol工具
<groupId>org.openjdk.jol</groupId>
<artifactId>jol-core</artifactId>
可以打印内存区域的数据,markword信息

#### 对象在jvm中的结构 ####
jvm是用c++编写，在c++的中使用Klass-oop对象模型，java的对象通过klass-oop映射到c++对象；oop是普通对象指针，klass包含元数据和方法信息，一分为二的对象模型即一个java对象分为了oop和klass

