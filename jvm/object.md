# 对象 #

#### 分配内存 ####
在类初始化加载的准备阶段分配了内存，接下来看一下创建对象的过程。如果类已经加载就不会再次加载，否则进行加载，在加载的过程分配内存的方式有两种，一种是指针碰撞，另外一种是空闲列表
指针碰撞：适用于堆内存完整的情况，已分配的内存和空闲内存分表在不同的一侧，通过一个指针指向分界点，当需要分配内存时，把指针往空闲的一端移动与对象大小相等的距离即可

空闲列表：
适用于堆内存不完整的情况，已分配的内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的内存块信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录

处理分配内存的并发问题：jvm使用cas和TLAB
TLAB：本地线程分配缓存。每个线程提前在eden区划分小一部分区域默认eden的1%，进行存放，使用参数-XX:TLABSize设置大小。如果对象过大，就使用cas分配。如果cas分配失败则重试；

#### 分配流程 ####
首先判断是否能在栈上分配，栈上分配的前提，是否开启对象逃逸分析，jdk7以后默认开启。参数是-XX:+DoEscapeAnalysis（锁消除也是在逃逸分析的基础上实现的-XX:+EliminateLocks），如果在栈上不能分配，判断是否开启标量替换，jdk7默认开启（-XX:+EliminateAllocations），因为栈空间比较小且可能有碎片，开启之后允许把对象拆散，把单个对象存入碎片中。如果不能在栈上分配就在堆中分配。在堆中分配也区分对象的大小。小对象在eden区分配，大对象存在在老年代或者是大对象区，取决于GC收集器。

#### 对象头 ####
分配内存之后就会，然后解析和初始化<clinit>，初始化之后进行对象头的设置。
对象的组成部分是对象头，实例数据，对齐填充（满足长度是8的倍数）；一个Object对象16字节
对象头包含了markword(hashcode，锁信息)，klass-point，数组长度；







